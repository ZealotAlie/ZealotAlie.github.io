---
title: "DirectX 11 学习笔记-01【Device基础】"
tags: 图形学
---

计算机绘图本质上绘制的是一张2D的平面图像。DirectX作为底层绘图API，提供了一组软件接口，我们可以通过这组接口来控制绘图硬件。而一个DirectX程序完成的工作，就是把一系列的信息转换为一张2D平面图形，并让它显示在屏幕上。<!--more-->

## Device和Device Context

Device是程序与硬件交互的接口。在DirectX中使用 ID3D11Device来表示一个Device，它被用于检测显示适配器功能和分配资源。每个应用都必须至少有一个Device。 

Device Context可以认为是Device的环境或者说是配置。更具体的说来，Device Context用于设置管线状态，将资源绑定到图形管线和生成渲染命令。 

## Resource和ResourceView 
资源（Resource）好比构建Scene的砖块，DirectX用于渲染场景的大部分数据来自于Resource。 

Resource包括以下几种类型的数据：geometry, textures, shader data。

使用Device来创建一个新的资源。资源对CPU和GPU可以有不同的访问权限。在一个每一个管线阶段，最多只能有128个资源被绑定。 

比较常见的资源类型有纹理。纹理的用途之一是用于存储图像数据，但不局限于此（例如法线贴图）。纹理有1D，2D和3D纹理，分别代表不同维度的数据元素数组。但实际上，由于mipmap的存在，纹理可以是一组数据数组。 

在创建资源时，可以用枚举DXGI_FORMAT指定资源的格式。当然也可以指定弱类型（typeless）格式，预先分配内存空间，然后在纹理绑定到管线时重新解释数据内容。使用弱类型时，程序无法对它进行访问优化。 

资源被存储为通用的内存格式，因此它可以被多个管线阶段所共享。在管线阶段中，使用资源视图（ResourceView）来解释资源数据，资源视图概念上类似于对资源数据的转换（casting），以便用于特定的管线中。资源视图告诉DirectX我们将如何使用这一资源，同一个资源可以有不同的用途，这种情况下我们只需要为它创建不同的资源视图即可。例如一个纹理在同时作为渲染目标和着色器资源时，我们需要为它创建两种视图：渲染目标视图（ID3D11RenderTargetView）和着色器资源视图（ID3D11ShaderResourceView）。 

需要注意的是，资源的用途在资源创建时就已经通过BindFlags确定，如果BindFlags中不包含资源视图类型所对应的Mask，那么创建资源视图时程序会报错。 

## Swap Chain和Viewport 

为了避免在动画过程中出现闪烁，最好的做法是在一个离屏纹理中执行所有的动画帧绘制工作，绘制完成后再把它作为完整的帧显示在屏幕上。在图形学中，交换链（swap chain）包含一系列能被显卡和图形API所利用的帧缓存。以双缓冲（有两个纹理缓冲区的交换链）为例，两个缓冲区分别被称为前台缓冲区（front buffer）和后台缓冲区（back buffer）。前台缓冲区存储了当前屏幕上显示的图像数据，而绘图工作在后台缓冲区上完成。程序将场景绘制在后台缓冲区中，当绘制完成时，两个缓冲区的作用将互换，后台缓冲区将作为前台缓冲区并将内容显示在显示器中，而前台缓冲区变为后台缓冲区，程序在新的后台缓冲区中绘制下一帧。这个过程被称为Present。交换通常只需要简单的交换指针即可，所以是一个很快的过程。

在DirectX中，交换链在创建时可以指定交换的方式，但通常情况下只需要设置为DXGI_SWAP_EFFECT_DISCARD，让显卡驱动自动选择最高效的交换方式即可。交换链通常存在于显存中，它也可以存在于系统内存中。DirectX中，交换链在创建时也会自动创建所需要的纹理缓冲区，我们不需要再为它额外创建纹理，只需要获取交换链中后台缓冲区的指针，并为它创建资源视图（Render Target Resource View），就可以将它绑定到渲染管线中，从而向缓冲区绘制图形。 

除了常见的双缓冲，交换链可以支持更多的缓冲区。更多的缓冲区会消耗更多的显存，游戏中常见的是三缓冲。

双缓冲虽然解决了画面闪烁的问题，但当图形绘制速度大于显示器的刷新速率时，可能出现前台缓冲区的内容还没完全显示在显示器上，新的图形帧就绘制完成，这时候交换链会交换两个缓冲区，下一帧的内容被绘制在屏幕上，但前一帧的一部分已经被绘制出来，即屏幕上有一部分是前一帧的内容，另一部分是新的内容，画面出现了撕裂。解决办法之一是垂直同步，让程序去等待屏幕刷新，例如屏幕的刷新率是60，那么当程序的帧数大于60时强制和屏幕同步为60。但当程序帧数不到60时，会同步到30帧，59帧也会强制同步到30帧，整体的流畅程度就大幅下降了。 

另一个解决方案是三缓冲。一个前台缓冲区用于屏幕绘制，剩下有两个后台缓冲区用于程序的绘制，当一个新的帧绘制完成时，如果当前的前台缓冲区还没绘制完，新的帧会存放在后台缓冲区，由于我们有两个后台缓冲区，那么另一个后台缓冲区可以用于下一帧的绘制，而屏幕刷新完毕以后，又可以立刻从后台缓冲区中取一帧来绘制到屏幕中，这样就不会出现画面撕裂。当程序绘制够快时，会有帧被丢弃的情况，但画面流畅度得到提升。 

最后讲Viewport。前面讲到程序能在后台缓冲区中绘制场景，但有些情况下我们不希望在整个后台缓冲区中绘制，那么我们可以使用VIewport来控制绘制的区域。Viewport指定了一个矩形区域，程序在这个矩形区域中绘制。在实际中，我们可以指定多个Viewport，并进行多次绘制，从而实现例如分屏的效果。 多次绘制多个Viewport的时候，只需要在所有绘制完成之后调用一次的Present即可。

## 参考资料

- 《Introduction to 3D Game Programming with Directx 11》

- [Wiki-SwapChain](https://en.wikipedia.org/wiki/Swap_Chain)

- [What Is a Swap Chain? (Direct3D 9)](https://docs.microsoft.com/en-us/windows/desktop/direct3d9/what-is-a-swap-chain-)